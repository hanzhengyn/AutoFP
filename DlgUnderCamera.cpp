// DlgUnderCamera.cpp : 实现文件
//

#include "stdafx.h"
#include "AutoFP.h"
#include "DlgUnderCamera.h"
#include "afxdialogex.h"
#include "DlgPosition.h"
#include "HalconCpp.h"
#include "BurningPort.h"
#include "MotionAct.h"	
#include "IoSd404.h"


// CDlgUnderCamera 对话框

IMPLEMENT_DYNAMIC(CDlgUnderCamera, CDialogEx)

CDlgUnderCamera::CDlgUnderCamera(CWnd* pParent /*=NULL*/)
    : CDialogEx(CDlgUnderCamera::IDD, pParent)
    , m_strCameraNum(_T("RH0892004016"))
    , m_strCameraVersion(_T(""))
    , m_strChipModel(_T(""))
{
    m_bCameraOpen = FALSE;
    m_dAngle = 0;
}

CDlgUnderCamera::~CDlgUnderCamera()
{
    if (m_bCameraOpen)
    {
        try
        {
            CloseFramegrabber(m_hv_AcqHandle_Down);
        }
        catch (HalconCpp::HException &HDevExpDefaultException)
        {
            //MessageBox("没有需要关闭的相机");
        }

    }
}

void CDlgUnderCamera::DoDataExchange(CDataExchange* pDX)
{
    CDialogEx::DoDataExchange(pDX);
    DDX_Text(pDX, IDC_EDIT_CAMERA_NUMBER, m_strCameraNum);
    DDX_Text(pDX, IDC_EDIT_CAMERA_VERSION, m_strCameraVersion);
    DDX_Text(pDX, IDC_EDIT_CHIPMODEL, m_strChipModel);
    DDX_Control(pDX, IDC_EDIT_CAMERA_VERSION, m_editCameraVersion);
    DDX_Control(pDX, IDC_EDIT_CAMERA_NUMBER, m_editCameraNum);
}


BEGIN_MESSAGE_MAP(CDlgUnderCamera, CDialogEx)
    ON_BN_CLICKED(IDC_BTN_CREATE_MODEL, &CDlgUnderCamera::OnBnClickedBtnCreateModel)
    ON_BN_CLICKED(IDC_BTN_CHECK_MODEL, &CDlgUnderCamera::OnBnClickedBtnCheckModel)
    ON_BN_CLICKED(IDC_BTN_NOZZLE2CAMERA, &CDlgUnderCamera::OnBnClickedBtnNozzle2camera)
    ON_BN_CLICKED(IDC_BTN_SAVE_NUZZLE, &CDlgUnderCamera::OnBnClickedBtnSaveNuzzle)
    ON_EN_CHANGE(IDC_EDIT_CAMERA_VERSION, &CDlgUnderCamera::OnEnChangeEditCameraVersion)
    ON_EN_CHANGE(IDC_EDIT_CAMERA_NUMBER, &CDlgUnderCamera::OnEnChangeEditCameraNumber)
    ON_WM_PAINT()
    ON_BN_CLICKED(IDC_BTN_GET_CHIP_TO_CAMERA, &CDlgUnderCamera::OnBnClickedBtnGetChipToCamera)
    ON_BN_CLICKED(IDC_BTN_ROTATION, &CDlgUnderCamera::OnBnClickedBtnRotation)
    ON_BN_CLICKED(IDC_BTN_MATCH_ADJUST, &CDlgUnderCamera::OnBnClickedBtnMatchAdjust)
    ON_BN_CLICKED(IDC_BTN_PUT_CHIP_TO_TAPE, &CDlgUnderCamera::OnBnClickedBtnPutChipToTape)
    ON_BN_CLICKED(IDC_BTN_ROTATION3, &CDlgUnderCamera::OnBnClickedBtnRotation3)
    ON_BN_CLICKED(IDC_RADIO1, &CDlgUnderCamera::OnBnClickedRadio1)
    ON_BN_CLICKED(IDC_RADIO2, &CDlgUnderCamera::OnBnClickedRadio2)
    ON_BN_CLICKED(IDC_RADIO3, &CDlgUnderCamera::OnBnClickedRadio3)
    ON_BN_CLICKED(IDC_RADIO4, &CDlgUnderCamera::OnBnClickedRadio4)
END_MESSAGE_MAP()


void CDlgUnderCamera::OpenFramegrab()
{
    //Image Acquisition 01: Code generated by Image Acquisition 01
    try
    {
        m_strCameraNum = gm_uInfo.strDownCameraNum;//MER-130-30UM-L
        m_strCameraVersion = gm_uInfo.strDownCameraVersion;
        HTuple Device = m_strCameraVersion + "(" + m_strCameraNum + ") producer:C:\\Program Files\\Daheng Imavision\\MER-Series\\GenTL\\Win32\\GxUSBTL.cti interface:0:DHUSBBase vendor:Daheng Imavision model:" + m_strCameraVersion;

        OpenFramegrabber("GenICamTL",
            0, 0, 0, 0, 0, 0,
            "progressive",
            -1,
            "default",
            -1,
            "false",
            "default",
            Device,
            0,
            -1,
            &m_hv_AcqHandle_Down);

        m_bCameraOpen = TRUE;

        SetFramegrabberParam(m_hv_AcqHandle_Down, "ExposureTime", EXPOSITION);

    }
    catch (HalconCpp::HException &HDevExpDefaultException)
    {
        MessageBox("OpenFramegrab Camera Error.");
        try
        {
            CloseFramegrabber(m_hv_AcqHandle_Down);
            m_bCameraOpen = FALSE;
            CDlgPosition *pWnd = (CDlgPosition*)GetParent();
            pWnd->InitCamera();
            pWnd->OpenSnapEx();
        }
        catch (HalconCpp::HException &HDevExpDefaultException)
        {
            //MessageBox("没有需要关闭的相机");
        }
    }
}

void CDlgUnderCamera::OnBnClickedBtnCreateModel()
{
    // TODO:  在此添加控件通知处理程序代码
    CDlgPosition* pWnd = (CDlgPosition*)GetParent();
    pWnd->CloseCamera();
    SetDownCameraLightOn();
    Sleep(100);
    //UpdateData();
    //gm_uInfo.strDownCameraNum = m_strCameraNum;
    //gm_uInfo.strDownCameraVersion
    InitModelCamera();
    //pWnd->InitCamera();
    //pWnd->OpenSnapEx();

}

void CDlgUnderCamera::InitModelCamera()
{
    try
    {
        OpenFramegrab();

        GrabImage(&m_ho_Image, m_hv_AcqHandle_Down);

        GetImageSize(m_ho_Image, &m_hv_Width, &m_hv_Height);

        // Initialize window
        CRect rt;
        GetDlgItem(IDC_CAMERA_FRAME)->GetWindowRect(&rt);
        ScreenToClient(rt);

        m_Window.OpenWindow(rt.top,
            rt.left,
            rt.Width(),
            rt.Height(),
            (Hlong)m_hWnd,
            "visible",
            "");

        m_Window.SetLineWidth(1);
        m_Window.DispObj(m_ho_Image);
        HTuple row1 = 512 - gm_uInfo.nChipWidth*gm_uInfo.nPixelsPM_down / 2 - 8;
        HTuple column1 = 640 - gm_uInfo.nChipLength*gm_uInfo.nPixelsPM_down / 2 - 8;
        HTuple row2 = 512 + gm_uInfo.nChipWidth*gm_uInfo.nPixelsPM_down / 2 + 8;
        HTuple column2 = 640 + gm_uInfo.nChipLength*gm_uInfo.nPixelsPM_down / 2 + 8;
        GenRectangle1(&m_ho_ROI_Model_Domain, row1, column1, row2, column2);

        ReduceDomain(m_ho_Image, m_ho_ROI_Model_Domain, &m_ho_ImageReduced);

        //MeanImage(m_ho_ImageReduced, &m_ho_ImageMean, 9, 9);
        //BinThreshold(m_ho_ImageMean, &m_ho_Region);
        //Connection(m_ho_Region, &m_ho_ConnectionRegions);
        //Union1(m_ho_ConnectionRegions, &m_ho_RegionUnion);
        //DilationCircle(m_ho_RegionUnion, &m_ho_RegionDilation, 0.5);
        //ReduceDomain(m_ho_Image, m_ho_RegionDilation, &m_ho_ImageReduced);

        //InspectShapeModel(m_ho_ImageReduced, &m_ho_ModelImages, &m_ho_ModelRegions, 1, 30);
        //CreateModel();
        CreateShapeModel(m_ho_ImageReduced,
            "auto",						//NumLevels
            HTuple(-45).TupleRad(),							//AngleStart
            HTuple(90).TupleRad(),		//AngleExtent
            "auto",						//AngleStep
            "auto",						//Optimization
            "use_polarity",	//Metric
            "auto",						//Contrast
            "auto",						//MinContrast
            &m_hv_ModelID);

        //GetShapeModelContours()

        FindShapeModel(m_ho_Image,
            m_hv_ModelID,				//ModelID
            HTuple(-45).TupleRad(),							//AngleStart
            HTuple(90).TupleRad(),		//AngleExtent
            0.1,						//MinScore
            1,							//NumMatches
            0.5,						//MaxOverlap
            "least_squares",			//SubPixel
            0,							//NumLevels
            0.9,						//Greediness
            &m_hv_Row,
            &m_hv_Column,
            &m_hv_Angle,
            &m_hv_Score);
        //GetShapeModelContours(&m_ho_ModelContours, m_hv_ModelID, 1);
        //dev_display_shape_matching_results(m_hv_ModelID, "green", m_hv_Row, m_hv_Column, m_hv_Angle,1, 1, 0);
        UpdateData();
        gm_strChipModel = m_strChipModel;
        CString strFile;
        GetDlgItemTextA(IDC_MFCEDITBROWSE2, strFile);
        HTuple filename = strFile;///*"c:/S100/Model/Chip/"+*/m_strChipModel;
        //WriteShapeModel(m_hv_ModelID, "c:/S100/Model/ChipModel.shm");
        WriteShapeModel(m_hv_ModelID, filename);

        gm_hv_Row_Chip = m_hv_Row;
        gm_hv_Column_Chip = m_hv_Column;
        gm_hv_Angle_Chip = m_hv_Angle;
        double a = m_hv_Angle;
        //if (abs(a) > 3.14)
        //{
        //	a = a - 2 * 3.1415;
        //}
        double x = m_hv_Column;
        double y = m_hv_Row;
        double s = m_hv_Score;

        m_Window.SetColor("red");
        CString str;
        m_Window.SetTposition(m_hv_Height - 400, 50);
        str.Format("匹配度:%0.2f", s);
        m_Window.WriteString(str);

        m_Window.SetTposition(m_hv_Height - 300, 50);
        str.Format("Offset Of Angle:%0.2f", a);
        m_Window.WriteString(str);

        m_Window.SetTposition(m_hv_Height - 200, 50);
        str.Format("Offset Of X:%0.2f", x);
        m_Window.WriteString(str);

        m_Window.SetTposition(m_hv_Height - 100, 50);
        str.Format("Offset Of Y:%0.2f", y);
        m_Window.WriteString(str);

        GetDlgItem(IDC_BTN_CHECK_MODEL)->EnableWindow();
        //Hlong row_model = atof((m_hv_Row.ToString()).Text());
        //Hlong column_model = atof((m_hv_Column.ToString()).Text());
        //m_Window.SetTposition(row_model, column_model);
        m_Window.SetDraw("margin");
        m_Window.SetColor("green");
        m_Window.DispObj(m_ho_ROI_Model_Domain);
        m_Window.SetColor("red");
        m_Window.DispCross(m_hv_Row, m_hv_Column, 1000, 0);

        CloseFramegrabber(m_hv_AcqHandle_Down);
        m_bCameraOpen = FALSE;
        CDlgPosition *pWnd = (CDlgPosition*)GetParent();
        pWnd->InitCamera();
        pWnd->OpenSnapEx();

    }
    catch (HalconCpp::HException &HDevExpDefaultException)
    {
        try
        {
            CloseFramegrabber(m_hv_AcqHandle_Down);
            m_bCameraOpen = FALSE;
            CDlgPosition *pWnd = (CDlgPosition*)GetParent();
            pWnd->InitCamera();
            pWnd->OpenSnapEx();
        }
        catch (HalconCpp::HException &HDevExpDefaultException)
        {
            //MessageBox("没有需要关闭的相机");
        }
        MessageBox("FindShapeModel Error.");
    }


}
void CDlgUnderCamera::CreateModel()
{
    try
    {
        CreateShapeModel(m_ho_ImageReduced,
            "auto",						//NumLevels
            HTuple(-45).TupleRad(),							//AngleStart
            HTuple(90).TupleRad(),		//AngleExtent
            0.0175,						//AngleStep
            "auto",						//Optimization
            "ignore_global_polarity",	//Metric
            "auto",						//Contrast
            "auto",						//MinContrast
            &m_hv_ModelID);
    }
    catch (HalconCpp::HException &HDevExpDefaultException)
    {
        try
        {
            CloseFramegrabber(m_hv_AcqHandle_Down);
            m_bCameraOpen = FALSE;
            CDlgPosition *pWnd = (CDlgPosition*)GetParent();
            pWnd->InitCamera();
            pWnd->OpenSnapEx();
        }
        catch (HalconCpp::HException &HDevExpDefaultException)
        {
        }
        MessageBox("CreateShapeModel Error.");
    }
}
Position2 CDlgUnderCamera::CheckModel()
{
    Position2 posOffset;
    posOffset.x = 0;
    posOffset.y = 0;
    posOffset.phi = 0;
    //m_ShapeModel.ReadShapeModel("/models/model0.shm");
    GenRectangle1(&m_ho_ROI_Search_Domain, 512 - 300, 640 - 300, 512 + 300, 640 + 300);
    try
    {
        //GrabImage(&m_ho_Image, m_hv_AcqHandle_Down);
        //Sleep(100);
        GrabImage(&m_ho_Image, m_hv_AcqHandle_Down);
        GetImageSize(m_ho_Image, &m_hv_Width, &m_hv_Height);

        // Initialize window
        CRect rt;
        GetDlgItem(IDC_CAMERA_FRAME)->GetWindowRect(&rt);
        ScreenToClient(rt);

        m_Window.OpenWindow(rt.top,
            rt.left,
            rt.Width(),
            rt.Height(),
            (Hlong)m_hWnd,
            "visible",
            "");

        //m_Window.SetPart(0, 0, m_hv_Width, m_hv_Height);
        m_Window.SetLineWidth(1);
        m_Window.DispObj(m_ho_Image);
        ReduceDomain(m_ho_Image, m_ho_ROI_Search_Domain, &m_ho_ImageReducedSearch);

        HTuple filename = /*"c:/S100/Model/Chip/"+*/m_strChipModel;

        ReadShapeModel(filename, &m_hv_ModelID);
        FindShapeModel(m_ho_Image,
            m_hv_ModelID,				//ModelID
            HTuple(-88).TupleRad(),							//AngleStart
            HTuple(88).TupleRad(),		//AngleExtent
            0.3,						//MinScore
            1,							//NumMatches
            0.5,						//MaxOverlap
            "least_squares",			//SubPixel
            0,							//NumLevels
            0.9,						//Greediness
            &m_hv_CheckRow,
            &m_hv_CheckColumn,
            &m_hv_CheckAngle,
            &m_hv_CheckScore);


        //GetShapeModelContours(&m_ho_ModelContours, m_hv_ModelID, 1);

        m_Window.SetColor("red");

        //	dev_display_shape_matching_results(m_ShapeModel.GetHandle(), "green", hv_Row, hv_Column, hv_Angle, 1, 1, 0);

        //		m_Window.SetColor("yellow");
        HTuple hv_AngleOffset, hv_ColumnOffset, hv_RowOffset;
        hv_AngleOffset = m_hv_CheckAngle - 0;
        hv_ColumnOffset = m_hv_CheckColumn - 640;
        hv_RowOffset = m_hv_CheckRow - 512;
        double a = hv_AngleOffset;
        if (abs(a) > 3.14)
        {
            a = a - 2 * 3.1415;
        }
        double x = hv_ColumnOffset;
        double y = hv_RowOffset;
        double s = m_hv_CheckScore;

        CString str;
        m_Window.SetTposition(m_hv_Height - 500, 50);
        str.Format("匹配度:%0.2f", s);
        m_Window.WriteString(str);

        m_Window.SetTposition(m_hv_Height - 400, 50);
        str.Format("Offset Of Angle:%0.2f", a);
        m_Window.WriteString(str);

        m_Window.SetTposition(m_hv_Height - 300, 50);
        str.Format("Offset Of X:%0.2f", x);
        m_Window.WriteString(str);

        m_Window.SetTposition(m_hv_Height - 200, 50);
        str.Format("Offset Of Y:%0.2f", y);
        m_Window.WriteString(str);

        m_Window.SetColor("green");
        m_Window.SetLineWidth(1);
        m_Window.DispCross(m_hv_CheckRow, m_hv_CheckColumn, 1000, a);

        double row = m_hv_CheckRow;
        double column = m_hv_CheckColumn;
        m_Window.SetColor("red");
        m_Window.SetDraw("margin");
        double length = gm_uInfo.nPixelsPM_down*gm_uInfo.nChipLength;
        double width = gm_uInfo.nPixelsPM_down*gm_uInfo.nChipWidth;

        m_Window.DispRectangle2(row, column, a, length / 2, width / 2);

        //	m_Window.DumpWindow("bmp", "/dump_window/halcon_dump00");
        posOffset.x = x;
        posOffset.y = y;
        posOffset.phi = a;

        CloseFramegrabber(m_hv_AcqHandle_Down);
        m_bCameraOpen = FALSE;
        //m_nOffsetX = x;
        //m_nOffsetY = y;
        //m_nOffsetAngle = a;
        UpdateData(FALSE);
    }
    catch (HalconCpp::HException &HDevExpDefaultException)
    {
        try
        {
            CloseFramegrabber(m_hv_AcqHandle_Down);
            m_bCameraOpen = FALSE;
            CDlgPosition *pWnd = (CDlgPosition*)GetParent();
            pWnd->InitCamera();
            pWnd->OpenSnapEx();
        }
        catch (HalconCpp::HException &HDevExpDefaultException)
        {
        }
        MessageBox("FindShapeModel Error.");
    }
    return posOffset;
}

void CDlgUnderCamera::OnBnClickedBtnCheckModel()
{
    // TODO:  在此添加控件通知处理程序代码
    SetDownCameraLightOn();
    Sleep(10);
    CheckModel();
    GetDlgItem(IDC_BTN_CHECK_MODEL)->EnableWindow(FALSE);
    try
    {
        CloseFramegrabber(m_hv_AcqHandle_Down);
        m_bCameraOpen = FALSE;
        CDlgPosition *pWnd = (CDlgPosition*)GetParent();
        pWnd->InitCamera();
        pWnd->OpenSnapEx();
    }
    catch (HalconCpp::HException &HDevExpDefaultException)
    {
    }
}


void CDlgUnderCamera::OnBnClickedBtnNozzle2camera()
{
    // TODO:  在此添加控件通知处理程序代码
    GetDlgItem(IDC_BTN_SAVE_NUZZLE)->EnableWindow();
    Point pt = gm_dataPos.GetPlacePoint("DownCamera");
    double x = pt.x;
    double y = pt.y;
    Point offset = gm_dataPos.GetPlacePoint("offset_nozzle1");
    if (!ZComeBack())
        return;
    SetAxisSpeed(XAXIS, 100, POSITION_SPEED);
    SetAxisSpeed(YAXIS, 100, POSITION_SPEED);
    int oldSpeed = gm_uInfo.xySpeed;
    gm_uInfo.xySpeed = 1;
    XYMove(x + offset.x, y + offset.y);
    gm_uInfo.xySpeed = oldSpeed;
    SetDownCameraLightOn();
}


void CDlgUnderCamera::OnBnClickedBtnSaveNuzzle()
{
    // TODO:  在此添加控件通知处理程序代码
    //GetDlgItem(IDC_BTN_SAVE_NUZZLE)->EnableWindow(FALSE);
    double x = GetPosition(XAXIS);
    double y = GetPosition(YAXIS);
    Point offset = gm_dataPos.GetPlacePoint("offset_nozzle1");
    gm_dataPos.SetPlacePoint("DownCamera", x - offset.x, y - offset.y);
}


void CDlgUnderCamera::OnEnChangeEditCameraVersion()
{
    // TODO:  如果该控件是 RICHEDIT 控件，它将不
    // 发送此通知，除非重写 CDialogEx::OnInitDialog()
    // 函数并调用 CRichEditCtrl().SetEventMask()，
    // 同时将 ENM_CHANGE 标志“或”运算到掩码中。

    // TODO:  在此添加控件通知处理程序代码
    UpdateData();
    gm_uInfo.strCameraNum = m_strCameraNum;
    gm_uInfo.strCameraVersion = m_strCameraVersion;
}


void CDlgUnderCamera::OnEnChangeEditCameraNumber()
{
    // TODO:  如果该控件是 RICHEDIT 控件，它将不
    // 发送此通知，除非重写 CDialogEx::OnInitDialog()
    // 函数并调用 CRichEditCtrl().SetEventMask()，
    // 同时将 ENM_CHANGE 标志“或”运算到掩码中。

    // TODO:  在此添加控件通知处理程序代码
    UpdateData();
    gm_uInfo.strCameraNum = m_strCameraNum;
    gm_uInfo.strCameraVersion = m_strCameraVersion;
}


BOOL CDlgUnderCamera::OnInitDialog()
{
    CDialogEx::OnInitDialog();

    // TODO:  在此添加额外的初始化
    m_strCameraNum = gm_uInfo.strDownCameraNum;
    m_strCameraVersion = gm_uInfo.strDownCameraVersion;
    //m_strChipModel = gm_strChipModel;
    SetDlgItemText(IDC_MFCEDITBROWSE2, gm_strChipModel);
    UpdateData(FALSE);
    return TRUE;  // return TRUE unless you set the focus to a control
    // 异常:  OCX 属性页应返回 FALSE
}


void CDlgUnderCamera::OnPaint()
{
    CPaintDC dc(this); // device context for painting
    // TODO:  在此处添加消息处理程序代码
    // 不为绘图消息调用 CDialogEx::OnPaint()
    CRect rtW, rtTop;
    GetWindowRect(rtW);
    ScreenToClient(rtW);

    CBrush brush(RGB(120, 226, 216));
    CBrush *pOldBrush = dc.SelectObject(&brush);
    dc.Rectangle(rtW);
    dc.SelectObject(pOldBrush);
}


void CDlgUnderCamera::OnBnClickedBtnGetChipToCamera()
{
    // TODO:  在此添加控件通知处理程序代码
    //GetDlgItem(IDC_BTN_PUT_CHIP_TO_TAPE)->EnableWindow(FALSE);
    GetDlgItem(IDC_BTN_GET_CHIP_TO_CAMERA)->EnableWindow(FALSE);
    Point pt = gm_dataPos.GetPlacePoint("Socket0");
    Point offset = gm_dataPos.GetPlacePoint("offset_nozzle1");
    double height = gm_dataPos.GetHeight("Socket0");
    SetCylinderDown(MODEL_0);
    if (!ZComeBack())
        return;
    SetAxisSpeed(XAXIS, 100, POSITION_SPEED);
    SetAxisSpeed(YAXIS, 100, POSITION_SPEED);
    int oldSpeed = gm_uInfo.xySpeed;
    gm_uInfo.xySpeed = 1;
    if (SUCCESS_BURNING != XYMove(pt.x + offset.x + gm_uInfo.nOffsetSocketX, pt.y + offset.y + gm_uInfo.nOffsetSocketY))
        return;
    if (!SzMove(height + gm_uInfo.nGetSocketHeight))
        return;
    UINT nResult = 0;
    nResult = GetChip(NOZZLE_0);
    //if (SUCCESS_BURNING != nResult)
    //{
    //	SetNozzleVaccumOff(NOZZLE_0);
    //	ZComeBack();
    //	AfxMessageBox("取料失败");
    //	return;
    //}

    pt = gm_dataPos.GetPlacePoint("DownCamera");
    //Point offset = gm_dataPos.GetPlacePoint("offset_nozzle1");
    if (!ZComeBack())
        return;
    SetAxisSpeed(XAXIS, 100, POSITION_SPEED);
    SetAxisSpeed(YAXIS, 100, POSITION_SPEED);
    XYMove(pt.x + offset.x, pt.y + offset.y);
    gm_uInfo.xySpeed = oldSpeed;
    SetDownCameraLightOn();
    GetDlgItem(IDC_BTN_GET_CHIP_TO_CAMERA)->EnableWindow();
    //GetDlgItem(IDC_BTN_PUT_CHIP_TO_TAPE)->EnableWindow();
}

//将芯片放回
void CDlgUnderCamera::OnBnClickedBtnPutChipToTape()
{
    //GetDlgItem(IDC_BTN_GET_CHIP_TO_CAMERA)->EnableWindow(FALSE);
    GetDlgItem(IDC_BTN_PUT_CHIP_TO_TAPE)->EnableWindow(FALSE);
    Point pt = gm_dataPos.GetPlacePoint("Socket0");
    Point offset = gm_dataPos.GetPlacePoint("offset_nozzle1");
    double height = gm_dataPos.GetHeight("Socket0");
    SetCylinderDown(MODEL_0);
    if (!ZComeBack())
        return;
    SetAxisSpeed(XAXIS, 100, POSITION_SPEED);
    SetAxisSpeed(YAXIS, 100, POSITION_SPEED);
    int oldSpeed = gm_uInfo.xySpeed;
    gm_uInfo.xySpeed = 1;
    if (SUCCESS_BURNING != XYMove(pt.x + offset.x + gm_uInfo.nOffsetSocketX, pt.y + offset.y + gm_uInfo.nOffsetSocketY))
        return;
    gm_uInfo.xySpeed = oldSpeed;
    if (!SzMove(height + gm_uInfo.nPutSocketHeight))
        return;
    PutChip(NOZZLE_0);

    if (!ZComeBack())
        return;
    SetDownCameraLightOff();
    GetDlgItem(IDC_BTN_PUT_CHIP_TO_TAPE)->EnableWindow();
    //GetDlgItem(IDC_BTN_GET_CHIP_TO_CAMERA)->EnableWindow();
}

//模型匹配调整
void CDlgUnderCamera::OnBnClickedBtnMatchAdjust()
{
    // TODO:  在此添加控件通知处理程序代码
    CDlgPosition* pWnd = (CDlgPosition*)GetParent();
    pWnd->CloseCamera();
    SetDownCameraLightOn();
    Point pt = gm_dataPos.GetPlacePoint("DownCamera");
    Point offset = gm_dataPos.GetPlacePoint("offset_nozzle1");
    OpenFramegrab();

    Position2 posOffset = CheckModel();
    SrMove(posOffset.phi, RAXIS_1);
    //posOffset = CheckModel();
    pt.x = pt.x - (XGUIDE / gm_uInfo.nPixelsPM_down*posOffset.x);//将像素偏差转换成脉冲偏差
    pt.y = pt.y - (YGUIDE / gm_uInfo.nPixelsPM_down*posOffset.y);

    if (!ZComeBack())
        return;
    SetAxisSpeed(XAXIS, 100, POSITION_SPEED);
    SetAxisSpeed(YAXIS, 100, POSITION_SPEED);
    int oldSpeed = gm_uInfo.xySpeed;
    gm_uInfo.xySpeed = 1;
    XYMove(pt.x + offset.x, pt.y + offset.y);
    gm_uInfo.xySpeed = oldSpeed;

    if (m_bCameraOpen)
    {
        try
        {
            CloseFramegrabber(m_hv_AcqHandle_Down);
            m_bCameraOpen = FALSE;
            CDlgPosition *pWnd = (CDlgPosition*)GetParent();
            pWnd->InitCamera();
            pWnd->OpenSnapEx();
        }
        catch (HalconCpp::HException &HDevExpDefaultException)
        {
            //MessageBox("没有需要关闭的相机");
        }
    }
}

//顺时针
void CDlgUnderCamera::OnBnClickedBtnRotation()
{
    // TODO:  在此添加控件通知处理程序代码
    SrMove(-m_dAngle*PI / 180, 0);
}

void CDlgUnderCamera::OnBnClickedBtnRotation3()
{
    SrMove(m_dAngle*PI / 180, 0);
}


void CDlgUnderCamera::OnBnClickedRadio1()
{
    // TODO:  在此添加控件通知处理程序代码
    m_dAngle = 0.1;
}


void CDlgUnderCamera::OnBnClickedRadio2()
{
    // TODO:  在此添加控件通知处理程序代码
    m_dAngle = 1;
}


void CDlgUnderCamera::OnBnClickedRadio3()
{
    // TODO:  在此添加控件通知处理程序代码
    m_dAngle = 90;
}


void CDlgUnderCamera::OnBnClickedRadio4()
{
    // TODO:  在此添加控件通知处理程序代码
    m_dAngle = 180;
}
