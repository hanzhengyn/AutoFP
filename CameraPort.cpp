#include "stdafx.h"
#include "HalconCpp.h"
#include "CameraPort.h"


CameraPort::CameraPort()
{
	m_bCameraOpenDown = FALSE;
	m_bCameraOpenUp = FALSE;
}


CameraPort::~CameraPort()
{
	try
	{
		if (m_bCameraOpenUp)
		{
			CloseFramegrabber(m_hv_AcqHandle_Up);
			m_bCameraOpenUp = FALSE;
		}
		if (m_bCameraOpenDown)
		{
			CloseFramegrabber(m_hv_AcqHandle_Down);
			m_bCameraOpenDown = FALSE;
		}
	}
	catch (HalconCpp::HException &HDevExpDefaultException)
	{
		//MessageBox("没有需要关闭的相机");
	}

}
void CameraPort::OpenFramegrabUp()
{
	//Image Acquisition 01: Code generated by Image Acquisition 01
	try
	{
		if (!m_bCameraOpenUp)
		{
			m_strCameraNum = gm_uInfo.strCameraNum;
			m_strCameraVersion = gm_uInfo.strCameraVersion;//MER-130-30UM-L
			HTuple Device = m_strCameraVersion + "(" + m_strCameraNum + ") producer:C:\\Program Files\\Daheng Imavision\\MER-Series\\GenTL\\Win32\\GxUSBTL.cti interface:0:DHUSBBase vendor:Daheng Imavision model:" + m_strCameraVersion;

			OpenFramegrabber("GenICamTL",
				0, 0, 0, 0, 0, 0,
				"progressive",
				-1,
				"default",
				-1,
				"false",
				"default",
				Device,
				0,
				-1,
				&m_hv_AcqHandle_Up);

			m_bCameraOpenUp = TRUE;

			SetFramegrabberParam(m_hv_AcqHandle_Up, "ExposureTime", EXPOSITION);
			//m_Window.SetPart(0, 0, m_hv_Width, m_hv_Height);
		}

	}
	catch (HalconCpp::HException &HDevExpDefaultException)
	{
		AfxMessageBox("OpenFramegrabUp Camera Error.");
	}
}
void CameraPort::OpenFramegrabDown()
{
	//Image Acquisition 01: Code generated by Image Acquisition 01
	try
	{
		if (!m_bCameraOpenDown)
		{
			m_strCameraNum = gm_uInfo.strDownCameraNum;
			m_strCameraVersion = gm_uInfo.strDownCameraVersion;//MER-130-30UM-L
			HTuple Device = m_strCameraVersion + "(" + m_strCameraNum + ") producer:C:\\Program Files\\Daheng Imavision\\MER-Series\\GenTL\\Win32\\GxUSBTL.cti interface:0:DHUSBBase vendor:Daheng Imavision model:" + m_strCameraVersion;

			OpenFramegrabber("GenICamTL",
				0, 0, 0, 0, 0, 0,
				"progressive",
				-1,
				"default",
				-1,
				"false",
				"default",
				Device,
				0,
				-1,
				&m_hv_AcqHandle_Down);

			m_bCameraOpenDown = TRUE;

			SetFramegrabberParam(m_hv_AcqHandle_Down, "ExposureTime", EXPOSITION);
			//m_Window.SetPart(0, 0, m_hv_Width, m_hv_Height);
		}
	}
	catch (HalconCpp::HException &HDevExpDefaultException)
	{
		AfxMessageBox("OpenFramegrabDown Camera Error.");
	}
}
BOOL CameraPort::CheckModel(Position2 &posOffset, LPCTSTR place)
{
	CString strPlace = place;
	posOffset.x = 0;
	posOffset.y = 0;
	posOffset.phi = 0;
	double length = 0;
	double width = 0;
	try
	{
		GenRectangle1(&m_ho_ROI_Search_Domain, 512 - 300, 640 - 300, 512 + 300, 640 + 300);

		if (strPlace.Compare("down_camera_in") == 0)
		{
			ReadShapeModel("c:/S100/Model/ChipModel.shm", &m_hv_ModelID);//下相机检测芯片角度位置偏差
			length = gm_uInfo.nPixelsPM_down*gm_uInfo.nChipLength;
			width = gm_uInfo.nPixelsPM_down*gm_uInfo.nChipWidth;
			GrabImage(&m_ho_Image, m_hv_AcqHandle_Down);
		}
		else if (strPlace.Compare("tape_in") == 0)
		{
			ReadShapeModel("c:/S100/Model/TapeInModel.shm", &m_hv_ModelID);//检测编带进料
			length = gm_uInfo.nPixelsPM_up*gm_uInfo.nChipLength;
			width = gm_uInfo.nPixelsPM_up*gm_uInfo.nChipWidth;
			GrabImage(&m_ho_Image, m_hv_AcqHandle_Up);
		}
		else if (strPlace.Compare("tape_out") == 0)
		{
			ReadShapeModel("c:/S100/Model/TapeOutModel.shm", &m_hv_ModelID);//检测编带出料
			length = gm_uInfo.nPixelsPM_up*gm_uInfo.nChipLength;
			width = gm_uInfo.nPixelsPM_up*gm_uInfo.nChipWidth;
			GrabImage(&m_ho_Image, m_hv_AcqHandle_Up);
		}
		else if (strPlace.Compare("socket") == 0)
		{
			ReadShapeModel("c:/S100/Model/SocketModel.shm", &m_hv_ModelID);//检测烧录座位置
			length = gm_uInfo.nPixelsPM_up*gm_uInfo.nChipLength * 20;
			width = gm_uInfo.nPixelsPM_up*gm_uInfo.nChipLength * 20;
			GrabImage(&m_ho_Image, m_hv_AcqHandle_Up);
		}
		else if (strPlace.Compare("socket_have_chip") == 0)
		{
			ReadShapeModel("c:/S100/Model/TapeInModel.shm", &m_hv_ModelID);//烧录座中检测是否有芯片，所以模型可以使用TapeIn的模型
			length = gm_uInfo.nPixelsPM_up*gm_uInfo.nChipLength;
			width = gm_uInfo.nPixelsPM_up*gm_uInfo.nChipWidth;
			GrabImage(&m_ho_Image, m_hv_AcqHandle_Up);
		}

		GetImageSize(m_ho_Image, &m_hv_Width, &m_hv_Height);

		FindShapeModel(m_ho_Image,
			m_hv_ModelID,				//ModelID
			HTuple(-45).TupleRad(),							//AngleStart
			HTuple(90).TupleRad(),		//AngleExtent  角度范围
			0.3,						//MinScore
			1,							//NumMatches
			0.5,						//MaxOverlap
			"least_squares",			//SubPixel
			0,							//NumLevels
			0.9,						//Greediness
			&m_hv_CheckRow,
			&m_hv_CheckColumn,
			&m_hv_CheckAngle,
			&m_hv_CheckScore);

		HTuple hv_AngleOffset, hv_ColumnOffset, hv_RowOffset;

		hv_AngleOffset = m_hv_CheckAngle - 0;// gm_hv_Angle_Chip;
		hv_ColumnOffset = m_hv_CheckColumn - 640;// gm_hv_Column_Chip;
		hv_RowOffset = m_hv_CheckRow - 512;// gm_hv_Row_Chip;

		double a = hv_AngleOffset;
		if (abs(a) > 3.14)
		{
			a = a - 2 * 3.1415;
		}
		double x = hv_ColumnOffset;
		double y = hv_RowOffset;
		double s = m_hv_CheckScore;
		if (s < 0.7)
		{
			return FALSE;
		}
		posOffset.x = x;
		posOffset.y = y;
		posOffset.phi = a;
		return TRUE;
	}
	catch (HalconCpp::HException &HDevExpDefaultException)
	{
		//CString str;
		//str.Format("故障代码：s%", HDevExpDefaultException.);
		//MessageBox(str);
		return FALSE;
	}
}

void CameraPort::CloseFramegrab()
{
	try
	{
		if (m_bCameraOpenUp)
		{
			CloseFramegrabber(m_hv_AcqHandle_Up);
			m_bCameraOpenUp = FALSE;
		}
		if (m_bCameraOpenDown)
		{
			CloseFramegrabber(m_hv_AcqHandle_Down);
			m_bCameraOpenDown = FALSE;
		}
	}
	catch (HalconCpp::HException &HDevExpDefaultException)
	{
		//MessageBox("没有需要关闭的相机");
	}

}
