// DlgModelCheck.cpp : 实现文件
//

#include "stdafx.h"
#include "AutoFP.h"
#include "DlgModelCheck.h"
#include "afxdialogex.h"
#include "DlgPosition.h"
#include "HalconCpp.h"
#include "BurningPort.h"
#include "MotionAct.h"
#include "IoSd404.h"


// CDlgModelCheck 对话框

IMPLEMENT_DYNAMIC(CDlgModelCheck, CDialogEx)

CDlgModelCheck::CDlgModelCheck(CWnd* pParent /*=NULL*/)
	: CDialogEx(CDlgModelCheck::IDD, pParent)
	, m_nOffsetX(0)
	, m_nOffsetY(0)
	, m_nOffsetAngle(0)
	, m_strCameraNum(_T("RH0892004016"))
	, m_strCameraVersion(_T(""))
	, m_strSocketModel(_T(""))
{
	m_bCameraOpenUp = FALSE;
}

CDlgModelCheck::~CDlgModelCheck()
{
	if (m_bCameraOpenUp)
	{
		try
		{
			if (m_bCameraOpenUp)
				CloseFramegrabber(m_hv_AcqHandle_Up);
		}
		catch (HalconCpp::HException &HDevExpDefaultException)
		{

		}

	}
}

void CDlgModelCheck::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
	DDX_Text(pDX, IDC_EDIT_OFFSET_X, m_nOffsetX);
	DDX_Text(pDX, IDC_EDIT_OFFSET_Y, m_nOffsetY);
	DDX_Text(pDX, IDC_EDIT_OFFSET_ANGLE, m_nOffsetAngle);
	DDX_Text(pDX, IDC_EDIT_CAMERA_NUMBER, m_strCameraNum);
	DDX_Text(pDX, IDC_EDIT_CAMERA_VERSION, m_strCameraVersion);
	DDX_Text(pDX, IDC_EDIT_MODEL_NAME, m_strSocketModel);
}


BEGIN_MESSAGE_MAP(CDlgModelCheck, CDialogEx)
	ON_BN_CLICKED(IDC_BTN_CREATE_MODEL, &CDlgModelCheck::OnBnClickedBtnCreateModel)
	ON_BN_CLICKED(IDC_BTN_CHECK_MODEL2, &CDlgModelCheck::OnBnClickedBtnCheckModel2)
	ON_BN_CLICKED(IDC_BTN_CLOSE, &CDlgModelCheck::OnBnClickedBtnClose)
	ON_BN_CLICKED(IDC_BTN_MOVE_TO_MODEL, &CDlgModelCheck::OnBnClickedBtnMoveToModel)
	ON_EN_CHANGE(IDC_EDIT_CAMERA_NUMBER, &CDlgModelCheck::OnEnChangeEditCameraNumber)
	ON_BN_CLICKED(IDC_BTN_CHECK_COORD, &CDlgModelCheck::OnBnClickedBtnCheckCoord)
	ON_EN_CHANGE(IDC_EDIT_CAMERA_VERSION, &CDlgModelCheck::OnEnChangeEditCameraVersion)
	ON_WM_PAINT()
END_MESSAGE_MAP()


// CDlgModelCheck 消息处理程序

BOOL CDlgModelCheck::OnInitDialog()
{
	CDialogEx::OnInitDialog();

	// TODO:  在此添加额外的初始化
	m_strCameraNum = gm_uInfo.strCameraNum;
	m_strCameraVersion = gm_uInfo.strCameraVersion;
	m_strSocketModel = gm_strSocketModel;
	UpdateData(FALSE);
	return TRUE;  // return TRUE unless you set the focus to a control
	// 异常:  OCX 属性页应返回 FALSE
}

void CDlgModelCheck::OpenFramegrab()
{
	//Image Acquisition 01: Code generated by Image Acquisition 01
	try
	{
		UpdateData();
		m_strCameraNum = gm_uInfo.strCameraNum;//MER-130-30UM-L
		m_strCameraVersion = gm_uInfo.strCameraVersion;
		HTuple Device = m_strCameraVersion + "(" + m_strCameraNum + ") producer:C:\\Program Files\\Daheng Imavision\\MER-Series\\GenTL\\Win32\\GxUSBTL.cti interface:0:DHUSBBase vendor:Daheng Imavision model:" + m_strCameraVersion;

		OpenFramegrabber("GenICamTL",
			0, 0, 0, 0, 0, 0,
			"progressive",
			-1,
			"default",
			-1,
			"false",
			"default",
			Device,
			0,
			-1,
			&m_hv_AcqHandle_Up);

		m_bCameraOpenUp = TRUE;

		SetFramegrabberParam(m_hv_AcqHandle_Up, "ExposureTime", EXPOSITION);

		GrabImage(&m_ho_Image, m_hv_AcqHandle_Up);

		GetImageSize(m_ho_Image, &m_hv_Width, &m_hv_Height);

		// Initialize window
		CRect rt;
		GetDlgItem(IDC_CAMERA_FRAME)->GetWindowRect(&rt);
		ScreenToClient(rt);

		m_Window.OpenWindow(rt.top,
			rt.left,
			rt.Width(),
			rt.Height(),
			(Hlong)m_hWnd,
			"visible",
			"");

		//m_Window.SetPart(0, 0, m_hv_Width, m_hv_Height);
		m_Window.SetLineWidth(1);
		m_Window.DispObj(m_ho_Image);
	}
	catch (HalconCpp::HException &HDevExpDefaultException)
	{
		if (m_bCameraOpenUp)
			CloseFramegrabber(m_hv_AcqHandle_Up);
		MessageBox("Initional Camera Error.");
	}
}

void CDlgModelCheck::CreateModel()
{
	try
	{
		OpenFramegrab();
		HTuple row1 = 512 - gm_uInfo.nSocketWidth*gm_uInfo.nPixelsPM_up / 2 - 8;
		HTuple column1 = 640 - gm_uInfo.nSocketLength*gm_uInfo.nPixelsPM_up / 2 - 8;
		HTuple row2 = 512 + gm_uInfo.nSocketWidth*gm_uInfo.nPixelsPM_up / 2 + 8;
		HTuple column2 = 640 + gm_uInfo.nSocketLength*gm_uInfo.nPixelsPM_up / 2 + 8;
		GenRectangle1(&m_ho_ROI_MODEL_DOMAIN, row1, column1, row2, column2);

		ReduceDomain(m_ho_Image, m_ho_ROI_MODEL_DOMAIN, &m_ho_ImageReduced);

		InspectShapeModel(m_ho_ImageReduced, &m_ho_ModelImages, &m_ho_ModelRegions, 1, 30);
	}
	catch (HalconCpp::HException &HDevExpDefaultException)
	{
		if (m_bCameraOpenUp)
			CloseFramegrabber(m_hv_AcqHandle_Up);
		MessageBox("Initional Camera Error.");
		return;
	}
	try
	{
		CreateShapeModel(m_ho_ImageReduced,
			"auto",						//NumLevels
			HTuple(-30).TupleRad(),							//AngleStart
			HTuple(60).TupleRad(),		//AngleExtent
			0.0175,						//AngleStep
			"auto",						//Optimization
			"ignore_global_polarity",	//Metric
			"auto",						//Contrast
			"auto",						//MinContrast
			&m_hv_ModelID);
	}
	catch (HalconCpp::HException &HDevExpDefaultException)
	{
		MessageBox("CreateShapeModel Error.");
		return;
	}
	try
	{

		FindShapeModel(m_ho_Image,
			m_hv_ModelID,				//ModelID
			HTuple(-30).TupleRad(),							//AngleStart
			HTuple(60).TupleRad(),		//AngleExtent
			0.5,						//MinScore
			1,							//NumMatches
			0.5,						//MaxOverlap
			"least_squares",			//SubPixel
			0,							//NumLevels
			0.9,						//Greediness
			&m_hv_Row,
			&m_hv_Column,
			&m_hv_Angle,
			&m_hv_Score);

		gm_hv_Row_Socket = m_hv_Row;
		gm_hv_Column_Socket = m_hv_Column;
		gm_hv_Angle_Socket = m_hv_Angle;
		UpdateData();
		gm_strSocketModel = m_strSocketModel;
		HTuple filename = /*"c:/S100/Model/Socket/" + */m_strSocketModel;
		//WriteShapeModel(m_hv_ModelID, "c:/S100/Model/SocketModel.shm");
		WriteShapeModel(m_hv_ModelID, filename);

		//GetShapeModelContours(&m_ho_ModelContours, m_hv_ModelID, 1);
		//dev_display_shape_matching_results(m_hv_ModelID, "green", m_hv_Row, m_hv_Column, m_hv_Angle,1, 1, 0);
		//WriteShapeModel(m_hv_ModelID, "c:/models/model1.shm");

		//Hlong row_model = atof((m_hv_Row.ToString()).Text());
		//Hlong column_model = atof((m_hv_Column.ToString()).Text());
		//m_Window.SetTposition(row_model, column_model);
		m_Window.SetDraw("margin");
		m_Window.SetColor("green");
		m_Window.DispObj(m_ho_ROI_MODEL_DOMAIN);
		m_Window.SetColor("red");
		m_Window.DispCross(m_hv_Row, m_hv_Column, 1000, 0);

		double a = m_hv_Angle;
		double x = m_hv_Column;
		double y = m_hv_Row;
		double s = m_hv_Score;
		m_Window.SetColor("red");
		CString str;
		m_Window.SetTposition(m_hv_Height - 400, 50);
		str.Format("匹配度:%0.2f%%", s * 100);
		m_Window.WriteString(str);

		m_Window.SetTposition(m_hv_Height - 300, 50);
		str.Format("Angle:%0.2f", a);
		m_Window.WriteString(str);

		m_Window.SetTposition(m_hv_Height - 200, 50);
		str.Format("X:%0.2f", x);
		m_Window.WriteString(str);

		m_Window.SetTposition(m_hv_Height - 100, 50);
		str.Format("Y:%0.2f", y);
		m_Window.WriteString(str);
	}
	catch (HalconCpp::HException &HDevExpDefaultException)
	{
		MessageBox("FindShapeModel Error.");
	}
}
Position2 CDlgModelCheck::CheckModel()
{
	Position2 posOffset;
	posOffset.x = 0;
	posOffset.y = 0;
	posOffset.phi = 0;
	try
	{
		GrabImage(&m_ho_Image, m_hv_AcqHandle_Up);
		HTuple filename = /*"c:/S100/Model/" +*/ m_strSocketModel;
		ReadShapeModel(filename, &m_hv_ModelID);
		//ReadShapeModel("c:/S100/Model/SocketModel.shm", &m_hv_ModelID);
		GrabImage(&m_ho_Image, m_hv_AcqHandle_Up);
		GetImageSize(m_ho_Image, &m_hv_Width, &m_hv_Height);

		HTuple row1 = 512 - gm_uInfo.nSocketWidth*gm_uInfo.nPixelsPM_up / 2 - 50;
		HTuple column1 = 640 - gm_uInfo.nSocketLength*gm_uInfo.nPixelsPM_up / 2 - 50;
		HTuple row2 = 512 + gm_uInfo.nSocketWidth*gm_uInfo.nPixelsPM_up / 2 + 50;
		HTuple column2 = 640 + gm_uInfo.nSocketLength*gm_uInfo.nPixelsPM_up / 2 + 50;
		GenRectangle1(&m_ho_ROI_MODEL_DOMAIN, row1, column1, row2, column2);

		ReduceDomain(m_ho_Image, m_ho_ROI_MODEL_DOMAIN, &m_ho_ImageReduced);

		// Initialize window
		CRect rt;
		GetDlgItem(IDC_CAMERA_FRAME)->GetWindowRect(&rt);
		ScreenToClient(rt);

		m_Window.OpenWindow(rt.top,
			rt.left,
			rt.Width(),
			rt.Height(),
			(Hlong)m_hWnd,
			"visible",
			"");

		//m_Window.SetPart(0, 0, m_hv_Width, m_hv_Height);
		m_Window.SetLineWidth(1);
		m_Window.DispObj(m_ho_Image);

		FindShapeModel(m_ho_Image,
			m_hv_ModelID,				//ModelID
			HTuple(-30).TupleRad(),							//AngleStart
			HTuple(60).TupleRad(),		//AngleExtent
			0.5,						//MinScore
			1,							//NumMatches
			0.5,						//MaxOverlap
			"least_squares",			//SubPixel
			0,							//NumLevels
			0.9,						//Greediness
			&m_hv_CheckRow,
			&m_hv_CheckColumn,
			&m_hv_CheckAngle,
			&m_hv_CheckScore);


		//GetShapeModelContours(&m_ho_ModelContours, m_hv_ModelID, 1);

		m_Window.SetColor("red");

		//	dev_display_shape_matching_results(m_ShapeModel.GetHandle(), "green", hv_Row, hv_Column, hv_Angle, 1, 1, 0);

		//m_Window.SetColor("yellow");
		HTuple hv_AngleOffset, hv_ColumnOffset, hv_RowOffset;
		hv_AngleOffset = m_hv_CheckAngle - 0;// gm_hv_Angle_Chip;
		hv_ColumnOffset = m_hv_CheckColumn - 640;// gm_hv_Column_Chip;
		hv_RowOffset = m_hv_CheckRow - 512;// gm_hv_Row_Chip;
		double a = hv_AngleOffset;
		double x = hv_ColumnOffset;
		double y = hv_RowOffset;
		double s = m_hv_CheckScore;

		CString str;
		m_Window.SetTposition(m_hv_Height - 500, 50);
		str.Format("匹配度:%0.2f", s);
		m_Window.WriteString(str);

		m_Window.SetTposition(m_hv_Height - 400, 50);
		str.Format("Offset Of Angle:%0.2f", a);
		m_Window.WriteString(str);

		m_Window.SetTposition(m_hv_Height - 300, 50);
		str.Format("Offset Of X:%0.2f", x);
		m_Window.WriteString(str);

		m_Window.SetTposition(m_hv_Height - 200, 50);
		str.Format("Offset Of Y:%0.2f", y);
		m_Window.WriteString(str);

		m_Window.SetColor("green");
		m_Window.SetLineWidth(1);
		m_Window.DispCross(m_hv_CheckRow, m_hv_CheckColumn, 1000, a);
		double length1 = gm_uInfo.nSocketWidth*gm_uInfo.nPixelsPM_up;// 280;
		double length2 = gm_uInfo.nSocketLength*gm_uInfo.nPixelsPM_up;// 280;
		double row = m_hv_CheckRow;
		double column = m_hv_CheckColumn;
		m_Window.SetColor("red");
		m_Window.SetDraw("margin");
		m_Window.DispRectangle2(row, column, a, length2 / 2, length1 / 2);
		//	m_Window.DumpWindow("bmp", "/dump_window/halcon_dump00");
		posOffset.x = x;
		posOffset.y = y;
		posOffset.phi = a;

		m_nOffsetX = x;
		m_nOffsetY = y;
		m_nOffsetAngle = a;
		UpdateData(FALSE);
	}
	catch (HalconCpp::HException &HDevExpDefaultException)
	{
		MessageBox("FindShapeModel Error.");
	}
	return posOffset;
}

void CDlgModelCheck::OnBnClickedBtnCreateModel()
{
	// TODO:  在此添加控件通知处理程序代码
	CDlgPosition* pWnd = (CDlgPosition*)GetParent();
	pWnd->CloseCamera();
	GetDlgItem(IDC_BTN_CHECK_MODEL2)->EnableWindow();
	SetUpCameraLightOn();
	Sleep(100);
	CreateModel();

	try
	{
		if(m_bCameraOpenUp)
			CloseFramegrabber(m_hv_AcqHandle_Up);
		m_bCameraOpenUp = FALSE;
		CDlgPosition *pWnd = (CDlgPosition*)GetParent();
		pWnd->InitCamera();
		pWnd->OpenSnapEx();
	}
	catch (HalconCpp::HException &HDevExpDefaultException)
	{
		//MessageBox("没有需要关闭的相机");
	}
}

void CDlgModelCheck::OnBnClickedBtnCheckModel2()
{
	// TODO:  在此添加控件通知处理程序代码
	//AfxBeginThread(CheckModelThread, this);
	GetDlgItem(IDC_BTN_CHECK_MODEL2)->EnableWindow(FALSE);
	CDlgPosition* pWnd = (CDlgPosition*)GetParent();
	pWnd->CloseCamera();
	OpenFramegrab();
	SetUpCameraLightOn();
	for (int i = 0; i<MAXNUMOFPROGRAMMER*MAXNUMOFSOCKET; i++)
	{
		GetDlgItem(IDC_BTN_CHECK_MODEL2)->EnableWindow(FALSE);		
		if (gm_bSocketUsed[i])
		{
		BOOL bCanMove = ZComeBack();
			if (!bCanMove)
				return ;
			CString secStr;
			secStr.Format("Socket%d", i);
			Point pt = gm_dataPos.GetPlacePoint((LPCSTR)secStr);
			double x = pt.x;
			double y = pt.y;
			if (!ZComeBack())
				return;
			SetAxisSpeed(XAXIS, 100, POSITION_SPEED);
			SetAxisSpeed(YAXIS, 100, POSITION_SPEED);
			int oldSpeed = gm_uInfo.xySpeed;
			gm_uInfo.xySpeed = 1;
			XYMove(x, y);
			gm_uInfo.xySpeed = oldSpeed;
			Position2 posOffset = CheckModel();
			//假设烧录座向右上角偏移，对于实际坐标，x，y都是减少了，但是对于像素坐标，x是增大了，y是减小了，所以x要减去偏差，y要加上偏差
			x = x - posOffset.x * XGUIDE / (double)gm_uInfo.nPixelsPM_up;//将像素偏差转换成脉冲偏差
			y = y + posOffset.y * YGUIDE / (double)gm_uInfo.nPixelsPM_up;
			gm_dataPos.SetPlacePoint((LPCSTR)secStr, x, y);
		}
	}
	AfxMessageBox("The Process of Checked has Finished.");
	//GetDlgItem(IDC_BTN_CLOSE)->EnableWindow();
	GetDlgItem(IDC_BTN_CHECK_MODEL2)->EnableWindow();
	SetUpCameraLightOff();

	try
	{
		if(m_bCameraOpenUp)
			CloseFramegrabber(m_hv_AcqHandle_Up);
		m_bCameraOpenUp = FALSE;
		CDlgPosition *pWnd = (CDlgPosition*)GetParent();
		pWnd->InitCamera();
		pWnd->OpenSnapEx();
	}
	catch (HalconCpp::HException &HDevExpDefaultException)
	{
		//MessageBox("没有需要关闭的相机");
	}
}


void CDlgModelCheck::OnBnClickedBtnClose()
{
	// TODO:  在此添加控件通知处理程序代码
	GetDlgItem(IDC_BTN_CLOSE)->EnableWindow(FALSE);

	try
	{
		if(m_bCameraOpenUp)
			CloseFramegrabber(m_hv_AcqHandle_Up);
		m_bCameraOpenUp = FALSE;
		CDlgPosition *pWnd = (CDlgPosition*)GetParent();
		pWnd->InitCamera();
		pWnd->OpenSnapEx();
	}
	catch (HalconCpp::HException &HDevExpDefaultException)
	{
		//MessageBox("没有需要关闭的相机");
	}
}
UINT CDlgModelCheck::CheckModelThread(LPVOID lParam)
{
	CDlgModelCheck *pMainWnd = (CDlgModelCheck*)lParam;
	for (int i = 0; i<MAXNUMOFPROGRAMMER*MAXNUMOFSOCKET; i++)
	{
		if (gm_bSocketUsed[i])
		{
			BOOL bCanMove = ZComeBack();
			if (!bCanMove)
				return 0;
			CString secStr;
			secStr.Format("Socket%d", i);
			Point pt = gm_dataPos.GetPlacePoint((LPCSTR)secStr);
			double x = pt.x;
			double y = pt.y;
			if (!ZComeBack())
				return 0;
			SetAxisSpeed(XAXIS, 100, POSITION_SPEED);
			SetAxisSpeed(YAXIS, 100, POSITION_SPEED);
			int oldSpeed = gm_uInfo.xySpeed;
			gm_uInfo.xySpeed = 1;
			XYMove(x, y);
			gm_uInfo.xySpeed = oldSpeed;
			Position2 posOffset = pMainWnd->CheckModel();
			//假设烧录座向右上角偏移，对于实际坐标，x，y都是减少了，但是对于像素坐标，x是增大了，y是减小了，所以x要减去偏差，y要加上偏差
			x = x - posOffset.x * 400 / gm_uInfo.nPixelsPM_up;//将像素偏差转换成脉冲偏差
			y = y + posOffset.y * 400 / gm_uInfo.nPixelsPM_up;
			gm_dataPos.SetPlacePoint((LPCSTR)secStr, x, y);
		}
	}
	AfxMessageBox("The Process of Checked has Finished.");
	return 1;
}

void CDlgModelCheck::OnBnClickedBtnMoveToModel()
{
	// 以第一个座子为匹配模型
	Point pt = gm_dataPos.GetPlacePoint("Socket0");
	double x = pt.x;
	double y = pt.y;
	if (!ZComeBack())
		return;
	SetAxisSpeed(XAXIS, 100, POSITION_SPEED);
	SetAxisSpeed(YAXIS, 100, POSITION_SPEED);
	int oldSpeed = gm_uInfo.xySpeed;
	gm_uInfo.xySpeed = 1;
	XYMove(x, y);
	gm_uInfo.xySpeed = oldSpeed;
}


void CDlgModelCheck::OnEnChangeEditCameraNumber()
{
	// TODO:  如果该控件是 RICHEDIT 控件，它将不
	// 发送此通知，除非重写 CDialogEx::OnInitDialog()
	// 函数并调用 CRichEditCtrl().SetEventMask()，
	// 同时将 ENM_CHANGE 标志“或”运算到掩码中。

	// TODO:  在此添加控件通知处理程序代码
	UpdateData();
	gm_uInfo.strCameraNum = m_strCameraNum;
	gm_uInfo.strCameraVersion = m_strCameraVersion;

}


//查看每个座子的坐标
void CDlgModelCheck::OnBnClickedBtnCheckCoord()
{
	// TODO:  在此添加控件通知处理程序代码
	for (int i = 0; i<MAXNUMOFPROGRAMMER*MAXNUMOFSOCKET; i++)
	{
		if (gm_bSocketUsed[i])
		{
			BOOL bCanMove = ZComeBack();
			if (!bCanMove)
				return;
			CString secStr;
			secStr.Format("Socket%d", i);
			Point pt = gm_dataPos.GetPlacePoint((LPCSTR)secStr);
			double x = pt.x;
			double y = pt.y;
			if (!ZComeBack())
				return;
			SetAxisSpeed(XAXIS, 100, POSITION_SPEED);
			SetAxisSpeed(YAXIS, 100, POSITION_SPEED);
			int oldSpeed = gm_uInfo.xySpeed;
			gm_uInfo.xySpeed = 1;
			XYMove(x, y);
			gm_uInfo.xySpeed = oldSpeed;
			Sleep(500);
		}
	}
}


void CDlgModelCheck::OnEnChangeEditCameraVersion()
{
	// TODO:  如果该控件是 RICHEDIT 控件，它将不
	// 发送此通知，除非重写 CDialogEx::OnInitDialog()
	// 函数并调用 CRichEditCtrl().SetEventMask()，
	// 同时将 ENM_CHANGE 标志“或”运算到掩码中。

	// TODO:  在此添加控件通知处理程序代码
	UpdateData();
	gm_uInfo.strCameraNum = m_strCameraNum;
	gm_uInfo.strCameraVersion = m_strCameraVersion;
}


void CDlgModelCheck::OnPaint()
{
	CPaintDC dc(this); // device context for painting
	// TODO:  在此处添加消息处理程序代码
	// 不为绘图消息调用 CDialogEx::OnPaint()
	CRect rtW, rtTop;
	GetWindowRect(rtW);
	ScreenToClient(rtW);

	CBrush brush(RGB(220, 226, 216));
	CBrush *pOldBrush = dc.SelectObject(&brush);
	dc.Rectangle(rtW);
	dc.SelectObject(pOldBrush);
}
